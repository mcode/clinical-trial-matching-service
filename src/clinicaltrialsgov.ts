/**
 * This file contains a backup system for finding necessary trial information if
 * your matching service does not provide it.
 *
 * The intended usages is essentially:
 *
 * Create the service:
 *
 * const ctgService = await createClinicalTrialsGovService('temp-data');
 *
 * Then, when ResearchStudy objects exist that need to be filled out, assuming
 * that studies is a ResearchStudy[]:
 *
 * await ctgService.updateResearchStudies(studies);
 *
 * This will fill out whatever can be filled out within the given studies.
 */

import fs from 'fs';
import path from 'path';
import * as xml2js from 'xml2js';
import * as https from 'https';
// Needed for types:
import * as http from 'http';
import * as stream from 'stream';
import { debuglog } from 'util';
import yauzl from 'yauzl';
import {
  CodeableConcept,
  ContactPoint,
  Group,
  Location,
  Reference,
  ResearchStudy,
  ResearchStudyStatus
} from './fhir-types';
import { ClinicalStudy, isClinicalStudy, StatusEnum } from './clinicalstudy';
import { addContainedResource, addToContainer } from './research-study';
// Import the AWS API.
var AWS = require('aws-sdk');
// Create an s3 access object.
var s3 = new AWS.S3();

/**
 * Logger type from the NodeJS utilities. (The TypeScript definitions for Node
 * don't bother naming this type.)
 */
type Logger = (message: string, ...param: unknown[]) => void;

/**
 * More for documentation purposes than anything else, this marks strings that are expected to be a valid NCT number.
 * (Generally they aren't checked to ensure they're valid, the methods involved will return nothing if they are not.)
 */
export type NCTNumber = string;

/**
 * This is the actual type generated by xml2js when the XML file is parsed.
 */
interface TrialBackup {
  clinical_study: ClinicalStudy;
}

export function isTrialBackup(o: unknown): o is TrialBackup {
  if (typeof o !== 'object' || o === null) {
    return false;
  }
  return 'clinical_study' in o && isClinicalStudy((o as TrialBackup).clinical_study);
}

/**
 * The URL for the "system" field of identifiers that indicate the
 * ClinicalTrial.gov identifier, or NTC number, of a clinical trial.
 */
export const CLINICAL_TRIAL_IDENTIFIER_CODING_SYSTEM_URL = 'http://clinicaltrials.gov/';

/**
 * Checks to ensure that a given NCT number is valid. This checks to make sure
 * it matches the regular expression /^NCT[0-9]{8}$/.
 * @param nctNumber the NCT number to check
 */
export function isValidNCTNumber(nctNumber: string): boolean {
  return /^NCT[0-9]{8}$/.test(nctNumber);
}

/**
 * Finds the NCT number specified for the given ResearchStudy, assuming there is
 * one. This requires an identifier on the given ResearchStudy that either
 * belongs to the coding system "http://clinicaltrials.gov/" or is a valid NCT
 * number as determined by #isValidNCTNumber.
 *
 * This will return the value of the first identifier belonging to the coding
 * system "http://clinicaltrials.gov/", and if there is no identifier, return
 * the first identifier value that is considered valid.
 *
 * @param study the research study
 * @returns the NCT number or null if none
 */
export function findNCTNumber(study: ResearchStudy): NCTNumber | null {
  if (study.identifier && Array.isArray(study.identifier) && study.identifier.length > 0) {
    for (const identifier of study.identifier) {
      if (identifier.system === CLINICAL_TRIAL_IDENTIFIER_CODING_SYSTEM_URL && typeof identifier.value === 'string')
        return identifier.value;
    }
    // Fallback: regexp match
    for (const identifier of study.identifier) {
      if (typeof identifier.value === 'string' && isValidNCTNumber(identifier.value)) return identifier.value;
    }
  }
  // Return null on failures
  return null;
}

/**
 * Finds all the NCT numbers within the given list of studies. Returns a map of
 * NCT numbers to the research studies they match. If multiple research studies
 * have the same NCT ID, then an array will be used to contain all matching
 * studies. (This should be very uncommon but is supported anyway.)
 * @param studies the NCT numbers found, if any
 */
export function findNCTNumbers(studies: ResearchStudy[]): Map<NCTNumber, ResearchStudy | Array<ResearchStudy>> {
  const result = new Map<NCTNumber, ResearchStudy | Array<ResearchStudy>>();
  for (const study of studies) {
    const nctId = findNCTNumber(study);
    // Skips problem NCT files.
    if (nctId !== null && nctId != 'NCT03980509' && nctId !== 'NCT03980509' && nctId !== 'NCT02788981' && nctId != 'NCT02788981' && nctId != '02788981' && nctId !== '02788981') {
      const existing = result.get(nctId);
      if (existing === undefined) {
        result.set(nctId, study);
      } else {
        if (Array.isArray(existing)) {
          existing.push(study);
        } else {
          result.set(nctId, [ existing, study ]);
        }
      }
    }
  }
  return result;
}

export async function parseClinicalTrialXML(fileContents: string, nctNumber: NCTNumber): Promise<ClinicalStudy> {
  const parser = new xml2js.Parser();
  fileContents = ("" + fileContents);
  console.log("File contents type: " + (typeof fileContents) + " for trial " + nctNumber + ".");
  console.log("File contents: " + (fileContents) + " for trial " + nctNumber + ".");
  return await parser.parseStringPromise(fileContents).then((result) => {
    if (isTrialBackup(result)) {
      return result.clinical_study;
    } else {
      throw new Error('Unable to parse trial as valid clinical study XML');
    }
  }).catch((err) => {
      fileContents = " "  +  (fileContents);
      console.log("Promise Catch File contents type: " + (typeof fileContents) + " for trial " + nctNumber + ".");
      console.log("Promise Catch File contents: " + (fileContents) + " for trial " + nctNumber + ".");
      return parser.parseStringPromise(fileContents).then((new_result) => {
        if (isTrialBackup(new_result)) {
          return new_result.clinical_study;
        } else {
          throw new Error('Unable to parse trial as valid clinical study XML - 2 - Error: ' + err + ' new result: ' + new_result  + " for trial " + nctNumber + ".");
        }
      });
  });
}

const CLINICAL_STATUS_MAP = new Map<StatusEnum, ResearchStudyStatus>([
  ['Active, not recruiting', 'closed-to-accrual'],
  ['Completed', 'completed'],
  // FIXME: This does not appear to have a proper mapping
  ['Enrolling by invitation', 'active'],
  ['Not yet recruiting', 'approved'],
  ['Recruiting', 'active'],
  ['Suspended', 'temporarily-closed-to-accrual'],
  ['Terminated', 'administratively-completed'],
  ['Withdrawn', 'withdrawn'],
  ['Available', 'completed'],
  ['No longer available', 'closed-to-accrual'],
  ['Temporarily not available', 'temporarily-closed-to-accrual'],
  ['Approved for marketing', 'completed'],
  // FIXME: This does not appear to have a proper mapping
  ['Withheld', 'in-review'],
  // FIXME: This does not appear to have a proper mapping
  ['Unknown status', 'in-review']
]);

export function convertClincalStudyStatusToFHIRStatus(status: StatusEnum): ResearchStudyStatus | undefined {
  return CLINICAL_STATUS_MAP.get(status);
}

function convertArrayToCodeableConcept(trialConditions: string[]): CodeableConcept[] {
  const fhirConditions: CodeableConcept[] = [];
  for (const condition of trialConditions) {
    fhirConditions.push({ text: condition });
  }
  return fhirConditions;
}

/**
 * A cache entry. Cache entries basically operate in two modes: an entry that is pending being written based on a ZIP
 * file, and a file that has a backing file ready to be loaded.
 *
 * The pending state is kind of weird because an entry is pending once a download has been requested for it, but cannot
 * be properly fulfilled until the file data has been saved. There's no really good way to wrap that in a Promise so
 * instead the resolve method is stored until the pending state can be resolved.
 */
export class CacheEntry {
  // Dates are, sadly, mutable via set methods. This makes it impractical to attempt to make them immutable.
  private _createdAt: Date;
  private _lastAccess: Date;
  /**
   * If this Promise exists, it puts the cache entry into a "pending" state and means a download has been started for
   * it. The Promise will resolve when the cache entry is "live."
   */
  private _pending: Promise<void> | undefined;
  /**
   * The resolve function of the pending Promise.
   */
  private _resolvePending: (() => void) | undefined;
  constructor(public filename: string, options: { stats?: fs.Stats, pending?: boolean }) {
    if (options.stats) {
      // Default to using the metadata from the fs.Stats object
      this._createdAt = options.stats.ctime;
      // Assume the last modified time was when the cache entry was fetched (it's close enough anyway)
      this._lastAccess = options.stats.mtime;
    } else {
      // Otherwise, default to now
      this._createdAt = new Date();
      this._lastAccess = new Date();
    }
    if (options.pending) {
      this._pending = new Promise((resolve) => {
        this._resolvePending = resolve;
      });
    }
  }
  get createdAt(): Date {
    return new Date(this._createdAt);
  }
  get lastAccess(): Date {
    return new Date(this._lastAccess);
  }
  get pending(): boolean {
    return this._pending !== undefined;
  }
  lastAccessedBefore(date: Date): boolean {
    return this._lastAccess < date;
  }

  /**
   * Resolves the pending state (if the entry was pending), otherwise does nothing.
   */
  ready(): void {
    if (this._resolvePending) {
      this._resolvePending();
    }
    this._pending = undefined;
    this._resolvePending = undefined;
  }

  /**
   * Loads the underlying file. If the entry is still pending, then the file is read once the entry is ready.
   */
  load(): Promise<ClinicalStudy> {
    // Move last access to now
    this._lastAccess = new Date();
    // If we're still pending, we have to wait for that to finish before we can
    // read the underlying file.
    if (this._pending) {
      return this._pending.then(() => {
        return this.readFile();
      });
    } else {
      // Otherwise we can just return immediately
      return this.readFile();
    }
  }

  /**
   * Always attempt to read the file, regardless of whether or not the entry is pending.
   */
  readFile(): Promise<ClinicalStudy> {
    return new Promise((resolve, reject) => {
      fs.readFile(this.filename, { encoding: 'utf8' }, (err, data) => {
        if (err) {
          reject(err);
        } else {
          // Again bump last access to now since the access has completed
          this._lastAccess = new Date();
          // Resolving with a Promise essentially "chains" that Promise
          resolve(parseClinicalTrialXML(data, "---"));
        }
      });
    });
  }

  /**
   * Remove the entry from the cache. All this does is delete the underlying file. The returned Promise is more for
   * error handling than anything else.
   */
  remove(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      fs.unlink(this.filename, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
}

/**
 * Create a directory if it does not already exist. If it does exist (or some other file exists in its place), this
 * still resolves rather than raising an error. This used to check if the paths were really directories, but since the
 * final step is now reading the file entries from the directory anyway, that check ensures everything is a directory
 * anyway.
 *
 * @param path the path to create (will be created recursively)
 * @return a Promise that resolves as true if the directory was newly created or false if it existed
 */
// export function mkdir(path: string): Promise<boolean> {
//   return new Promise<boolean>((resolve, reject) => {
//     fs.mkdir(path, (err) => {
//       if (err) {
//         if (err.code === 'EEXIST') {
//           // This is fine - resolve false. We'll only get this if the final part of the path exists (although it will be
//           // EEXIST regardless of if it's a directory or a regular file)
//           resolve(false);
//         } else {
//           reject(err);
//         }
//       } else {
//         resolve(true);
//       }
//     });
//   });
// }

export interface ClinicalTrialsGovServiceOptions {
  /**
   * The logging function to use to log debug information. If not set the default is `debuglog('ctgovservice')` from
   * the `util` module in Node.js.
   */
  log?: Logger;
  /**
   * Time in milliseconds to expire files after.
   */
  expireAfter?: number;
  /**
   * Interval in milliseconds to run periodic cache clean-ups. If set to 0 or infinity, never run cleanups.
   */
  cleanInterval?: number;
}

/**
 * System to fill in data on research studies based on the trial data from
 * https://clinicaltrials.gov/
 *
 * The current system works as follows:
 *
 * Call updateResearchStudies() with the ResearchStudy objects to update. It will locate all ResearchStudy objects that
 * contain an NCT ID. It will then:
 *
 * 1. Call downloadTrials() is used to download the ClinicalStudy data from clinicaltrials.gov. It starts an HTTPS
 *    request to download the trial results and, if successful, passes the response stream off to extractResults().
 * 2. extractResults() saves the stream its given to a temporary ZIP file and extracts that file to a temporary
 *    directory. Once the ZIP is extracted, it deletes the temporary ZIP. It then returns the directory where the files
 *    were extracted.
 * 3. With the path to the extracted ZIP, updateResearchStudies() can now use the downloaded trial data to update the
 *    trials.
 * 4. Before resolving, the temporary directory is deleted.
 *
 * A future version will likely change this to make it so that rather than immediately deleting the temporary trial
 * data, it's kept around in a least-recently-used cache and only deleted as the cache exceeds a given size. This will
 * add a few new public APIs to enable the retrieval of clinical study data by NCT ID. Right now, though, there is no
 * way to extract the clinical study data directly.
 */
export class ClinicalTrialsGovService {
  /**
   * Internal value to track temporary file names.
   */
  private tempId = 0;

  /**
   * Log used to log debug information. Either passed in at creation time or created via the Node.js util.debuglog
   * function. With the latter, activate by setting the NODE_DEBUG environment variable to "ctgovservice" (or include it
   * in a comma separated list of debugging modules to include).
   */
  private log: Logger;

  private _maxTrialsPerRequest = 128;
  /**
   * The maximum number of trials to attempt to download in a single request. Each NCT ID increases the URI size by
   * effectively 15 bytes: essentially each NCT ID becomes '+OR+NCT12345678'. The request path "counts" as a header and
   * has to be smaller than maxHeaderSize given to the client. By default, this uses the default client, so the client
   * should be the default HTTPS client. In theory this would support around 500 per request, instead this defaults to
   * 128 which is a nice round number. (In binary, at least.)
   */
  get maxTrialsPerRequest(): number {
    return this._maxTrialsPerRequest;
  }

  set maxTrialsPerRequest(newValue: number) {
    // Basically, just make sure the new value is positive and an integer. Positive infinity is fine and remains
    // positive infinity: it means never split.
    if (newValue > 1) {
      this._maxTrialsPerRequest = Math.floor(newValue);
    }
  }

  private _expirationTimeout = 60 * 60 * 1000;

  /**
   * The expiration timeout, the time in milliseconds after a cache entry should be considered expired. The default
   * is 1 hour.
   */
  get expirationTimeout(): number {
    return this._expirationTimeout;
  }

  set expirationTimeout(value: number) {
    // Ensure it's at least 1000ms
    this._expirationTimeout = Math.max(value, 1000);
  }

  private _cleanupIntervalMillis = 0;

  /**
   * The interval between cleanup sweeps. Set to 0 (or any negative value) or Infinity to disable periodic cleanup. Note
   * that the value is limited to the range 60000 (a minute)-2147483647 (the maximum value of a signed 32-bit integer)
   * as that maximum value is the maximum allowed timeout for a timer within Node.js. If the value is set to a negative
   * number or Infinity, the retrieved value will be 0, to indicate that the interval will not be set.
   */
  get cleanupInterval(): number {
    return this._cleanupIntervalMillis;
  }

  set cleanupInterval(value: number) {
    // Clamp it to 0 (special value for "never") or at least 60000 - also clamp the maximum to a 32-bit signed integer
    // which is the maximum allowed timeout within Node.js. (Exceeding that value changes the timeout to 1ms. Surprise!
    // I mean, sure, that's documented, but...)
    this._cleanupIntervalMillis = value <= 0 ? 0 : (value === Infinity ? 0 : Math.min(Math.max(Math.floor(value), 60000), 0x7FFFFFFF));
  }

  /**
   * The maximum allowed entry size before it is rejected. Default is 128MB, which is hopefully well more than necessary
   * for any reasonable clinical trial XML.
   */
  maxAllowedEntrySize = 128 * 1024 * 1024;

  // private cacheDataDir: string;

  /**
   * Actual cache of NCT IDs to their cached values. This is the "real cache" versus whatever's on the filesystem.
   * (The NCT ID is in the form that returns true from isValidNCTNumber, so NCTnnnnnnnn where n are digits.)
   */
  private cache = new Map<NCTNumber, CacheEntry>();

  private cleanupTimeout: NodeJS.Timeout | null = null;

  /**
   * Creates a new instance. This will not initialize the cache or load anything, this merely creates the object. Use
   * the #init() method to initialize the service and load existing data. (Or use createClinicalTrialsGovService() do
   * construct and initialize at the same time.)
   *
   * @param dataDir the directory to use for cache data
   * @param log an optional function to receive debug log messages. By default this uses util.debuglog('ctgovservice')
   *     meaning that the log can be activated by setting NODE_DEBUG to "ctgovservice"
   */
  constructor(public readonly dataDir: string, options?: ClinicalTrialsGovServiceOptions) {
    // this.cacheDataDir = path.join(dataDir, 'data');
    const log = options ? options.log : null;
    // If no log was given, create it
    this.log = log ?? debuglog('ctgovservice');
    // Default expiration timeout to an hour
    this.expirationTimeout = options?.expireAfter ?? 60 * 60 * 1000;
    // Default cleanup interval to an hour
    this.cleanupInterval = options?.cleanInterval ?? 60 * 60 * 1000;
  }

  /**
   * Creates the necessary directories if they do not exist, and loads any existing data into the cache. Parent
   * directories of the cache will not be created automatically, they must already exist.
   */
  async init(): Promise<void> {
    // this.log('Using %s as cache dir for clinicaltrials.gov data', this.dataDir);
    // const baseDirExisted = !(await mkdir(this.dataDir));
    // // The XML
    // const xmlDirExisted = !(await mkdir(this.cacheDataDir));
    // if (baseDirExisted && xmlDirExisted) {
    //   // If both directories existed, it's necessary to restore the cache directory
    //   await this.restoreCacheFromFS();
    //   this.log('Restored existing cache data.');
    // } else {
    //   this.log(baseDirExisted ? 'Created XML directory for storing result' : 'Created new cache directory');
    // }
    // // Once started, run the cache cleanup every _cleanupIntervalMillis
    // this.setCleanupTimeout();
  }

  /**
   * Sets the timeout interval assuming it was set.
   */
  private setCleanupTimeout(): void {
    // If set to infinity we internally set it to 0
    if (this._cleanupIntervalMillis > 0) {
      this.cleanupTimeout = setTimeout(() => {
        this.removeExpiredCacheEntries().then(() => {
          // Set up to do this again when that's done
          this.setCleanupTimeout();
        }, (error) => {
          this.log('Error cleaning expired cache entries: %o', error);
          // Even though this attempt failed, try again later
          this.setCleanupTimeout();
        });
      }, this._cleanupIntervalMillis);
    }
  }

  /**
   * Shuts down the service, doing any final necessary cleanup. At present this stops any running timers. The Promise
   * returned currently resolves immediately, but in the future, it may resolve asynchronously when the service has been
   * cleanly shut down.
   */
  destroy(): Promise<void> {
    if (this.cleanupTimeout !== null) {
      clearTimeout(this.cleanupTimeout);
      // And blank it
      this.cleanupTimeout = null;
    }
    return Promise.resolve();
  }

  /**
   * This attempts to load the cache from the filesystem.
   */
  // private restoreCacheFromFS(): Promise<void> {
  //   return new Promise<void>((resolve, reject) => {
  //     this.log('Scanning %s for existing cache entries...', this.cacheDataDir);
  //     fs.readdir(this.cacheDataDir, (err, files) => {
  //       if (err) {
  //         reject(err);
  //       } else {
  //         // Go through the files and create entries for them.
  //         const promises: Promise<void>[] = [];
  //         for (const file of files) {
  //           this.log('Checking %s', file);
  //           // Split this file name into two parts: the extension and the base name
  //           const dotIdx = file.lastIndexOf('.');
  //           if (dotIdx < 1) {
  //             // Skip "bad" files
  //             continue;
  //           }
  //           // FIXME: This is probably a bad idea. Right now the file name serves as the "master" name for files. It's
  //           // probably possible to load the file and pull the NCT ID out that way, as well as clear out files that
  //           // can't be parsed.
  //           const baseName = file.substring(0, dotIdx);
  //           const extension = file.substring(dotIdx + 1);
  //           if (isValidNCTNumber(baseName) && extension === 'xml') {
  //             promises.push(this.createCacheEntry(baseName, path.join(this.cacheDataDir, file)));
  //           }
  //         }
  //         Promise.all(promises).then(() => { resolve(); }, reject);
  //       }
  //     });
  //   });
  // }

  // private createCacheEntry(id: NCTNumber, filename: string): Promise<void> {
  //   // Restoring this involves getting the time the file was created so we know when the entry expires
  //   return new Promise((resolve, reject) => {
  //     fs.stat(filename, (err, stats) => {
  //       if (err) {
  //         // TODO (maybe): Instead of rejecting, just log - rejecting will caused Promise.all to immediately reject and
  //         // ignore the rest of the Promises. However, stat failing is probably a "real" error.
  //         reject(err);
  //       } else {
  //         this.cache.set(id, new CacheEntry(filename, { stats: stats }));
  //         this.log('Restored cache entry for %s', filename);
  //         resolve();
  //       }
  //     });
  //   });
  // }

  //   private createCacheEntryFromS3(id: NCTNumber, filename: string): Promise<void> {
  //   // Restoring this involves getting the time the file was created so we know when the entry expires

    

  //   return new Promise((resolve, reject) => {
  //     fs.stat(filename, (err, stats) => {
  //       if (err) {
  //         // TODO (maybe): Instead of rejecting, just log - rejecting will caused Promise.all to immediately reject and
  //         // ignore the rest of the Promises. However, stat failing is probably a "real" error.
  //         reject(err);
  //       } else {
  //         this.cache.set(id, new CacheEntry(filename, { stats: stats }));
  //         this.log('Restored cache entry for %s', filename);
  //         resolve();
  //       }
  //     });
  //   });
  // }

  /**
   * Attempts to update the given research studies with data from within this store. This returns a Promise that
   * resolves when the research studies have been updated with any available additional data. The Promise may be
   * rejected if the process fails entirely (that is, clinicaltrials.gov could not be contacted at all, or an I/O error
   * occurs).
   *
   * @param studies the studies to attempt to update
   * @returns a Promise that resolves when the studies are updated. It will resolve with the same array that was passed
   *     in - this updates the given objects, it does not clone them and create new ones.
   */
  updateResearchStudies(studies: ResearchStudy[]): Promise<ResearchStudy[]> {

    const nctIdMap = findNCTNumbers(studies);
    if (nctIdMap.size === 0) {
      // Nothing to do
      return Promise.resolve(studies);
    } else {
      const nctIds = Array.from(nctIdMap.keys());
      // Make sure the NCT numbers are in the cache
      // return this.ensureTrialsAvailable(nctIds).then(() => {
        const promises: Promise<ClinicalStudy | null>[] = [];
        // Go through the NCT numbers we found and updated all matching trials
        for (const entry of nctIdMap.entries()) {
          const [nctId, study] = entry;
          const promise = this.getCachedClinicalStudyFromS3Bucket(nctId);
          promises.push(promise);
          promise.then((clinicalStudy) => {
            if (clinicalStudy !== null) {
              // Make sure we have data to use - we may still get null if there was no data for a given NCT number
              // Update whatever trials we have
              if (Array.isArray(study)) {
                for (const s of study) {
                  this.updateResearchStudy(s, clinicalStudy);
                }
              } else {
                this.updateResearchStudy(study, clinicalStudy);
              }
            }
          });
        }
        // Finally resolve to the promises we were given
        return Promise.all(promises).then(() => studies);
      // });
    }
  }

  /**
   * Tells the cache to delete all expired cached files. The entries are removed from access immediately, but a Promise
   * is returned that resolves when all the underlying data is cleaned up. This Promise is more for error handling than
   * anything else.
   */
  removeExpiredCacheEntries(): Promise<void> {
    const expiredEntries: CacheEntry[] = [];
    const expiredIds: string[] = [];
    // Go through the cache and find all expired entries
    const expired = new Date();
    expired.setTime(expired.getTime() - this._expirationTimeout);
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessedBefore(expired)) {
        expiredIds.push(key);
        expiredEntries.push(entry);
      }
    }
    const expiredPromises: Promise<void>[] = [];
    // Now that the expired entries have been found, remove them
    for (const key of expiredIds) {
      this.cache.delete(key);
    }
    // FIXME: It's unclear whether or not this creates a race condition where it may be possible for another request
    // for an entry we just expired to be deleted before the new entry is ready. This is somewhat unlikely, but it's
    // something that could probably be fixed by ensuring that each time we create a cache entry we use a unique
    // filename.
    for (const entry of expiredEntries) {
      expiredPromises.push(entry.remove());
    }

    // The "then" essentially removes the array of undefined that will result
    // into a single undefined.
    return Promise.all(expiredPromises).then(() => { /* do nothing */ });
  }

  /**
   * Ensures that a given set of NCT IDs is available within the service, assuming they exist on ClinicalTrials.gov.
   * @param ids the IDs to ensure are available
   * @returns a Promise that resolves once any downloads have completed
   */
  // ensureTrialsAvailable(ids: string[]): Promise<void>;
  // ensureTrialsAvailable(studies: ResearchStudy[]): Promise<void>;
  // ensureTrialsAvailable(idsOrStudies: Array<string | ResearchStudy>): Promise<void> {
  //   // We only want string IDs and we may end up filtering some of them out
  //   const ids: string[] = [];
  //   for (const o of idsOrStudies) {
  //     if (typeof o === 'string') {
  //       if (isValidNCTNumber(o))
  //         ids.push(o);
  //     } else {
  //       const id = findNCTNumber(o);
  //       if (id)
  //         ids.push(id);
  //     }
  //   }
  //   // Now that we have the IDs, we can split them into download requests
  //   const promises: Promise<void>[] = [];
  //   for (let start = 0; start < ids.length; start += this.maxTrialsPerRequest) {
  //     promises.push(this.downloadTrials(ids.slice(start, Math.min(start + this.maxTrialsPerRequest, ids.length))));
  //   }
  //   return Promise.all(promises).then(() => {
  //     // This exists solely to turn the result from an array of nothing into a single nothing
  //   });
  // }

  /**
   * Downloads the given trials from ClinicalTrials.gov and stores them in the data directory. Note that this will
   * always replace trials if they exist.
   *
   * @param ids the IDs of the trials to download
   * @returns a Promise that resolves to the path where the given IDs were downloaded
   */
  // protected downloadTrials(ids: string[]): Promise<void> {
  //   const url = 'https://clinicaltrials.gov/ct2/download_studies?term=' + ids.join('+OR+');
  //   // Now that we're starting to download clinical trials, immediately create pending entries for them.
  //   for (const id of ids) {
  //     if (!this.cache.has(id)) {
  //       this.cache.set(id, new CacheEntry(this.pathForNctNumber(id), { pending: true }));
  //     }
  //   }
  //   const result = new Promise<void>((resolve, reject) => {
  //     this.log('Fetching [%s]', url);
  //     this.getURL(url, (response) => {
  //       if (response.statusCode !== 200) {
  //         this.log('Error %d %s from server', response.statusCode, response.statusMessage);
  //         // Resume the response to ensure it gets cleaned up properly
  //         response.resume();
  //         // Assume some sort of server error
  //         reject(new Error(`Server error: ${response.statusCode} ${response.statusMessage}`));
  //       } else {
  //         this.extractResults(response).then(resolve, reject);
  //       }
  //     }).on('error', (error) => {
  //       this.log('Error fetching [%s]: %o', url, error);
  //       reject(error);
  //     });
  //   })
  //   // Add a catch handler
  //   result.catch(() => {
  //     // If an error occurred within this promise, every cache entry we just loaded may be invalid.
  //     this.log('Invalidating cache entry IDs for: %s', ids);
  //     for (const id of ids) {
  //       const entry = this.cache.get(id);
  //       if (entry && entry.pending) {
  //         this.cache.delete(id);
  //       }
  //     }
  //   });
  //   // But return the root promise (otherwise we chain off the result handler)
  //   return result;
  // }

  /**
   * Provides a method that can be overridden to alter how a web request is
   * made. Defaults to simply calling https.get directly.
   * @param url the URL to get
   * @param callback the callback
   */
  protected getURL(url: string, callback: (res: http.IncomingMessage) => void): http.ClientRequest {
    return https.get(url, callback);
  }

  /**
   * Internal method to create a temporary file within the data directory. Temporary files created via this method
   */
  // private createTemporaryFileName(): string {
  //   // For now, temporary files are always "temp-[DATE]-[PID]-[TEMPID]" where [TEMPID] is an incrementing internal ID.
  //   // This means that temp files should never collide across processes or within a process. However, if a temporary
  //   // file is created and then the server is restarted and it somehow manages to get the same PID, a collision can
  //   // happen in that case.
  //   const now = new Date();
  //   return [
  //     'temp-',
  //     now.getUTCFullYear(),
  //     (now.getUTCMonth()+1).toString().padStart(2, '0'),
  //     now.getUTCDate().toString().padStart(2, '0'),
  //     '-',
  //     process.pid,
  //     '-',
  //     this.tempId++
  //   ].join('');
  // }

  // /**
  //  * Create a path to the data file that stores data about a cache entry.
  //  * @param nctNumber the NCT number
  //  */
  // private pathForNctNumber(nctNumber: NCTNumber): string {
  //   // FIXME: It's probably best not to use the NCT number as the sole part of the filename. See
  //   // removeExpiredCacheEntries for details.
  //   return path.join(this.cacheDataDir, nctNumber + '.xml');
  // }

  /**
   * Extract a given set of results, updating any cache results with the contents.
   * @param results a readable stream that contains a ZIP file that contains the results
   * @returns a Promise that resolves when the files have been extracted
   */
  // protected extractResults(results: stream.Readable): Promise<void> {
  //   const tempName = this.createTemporaryFileName();
  //   const zipFilePath = path.join(this.dataDir, tempName + '.zip');
  //   const file = fs.createWriteStream(zipFilePath);
  //   return new Promise<void>((resolve, reject) => {
  //     this.log('Saving download to [%s]...', zipFilePath);
  //     results.on('error', (err: Error) => {
  //       reject(err);
  //     });
  //     results.pipe(file).on('close', () => {
  //       // Extract the file
  //       this.extractZip(zipFilePath)
  //         .then(() => {
  //           // Since it's done, we should be able to delete the ZIP file now
  //           fs.unlink(zipFilePath, (error) => {
  //             if (error) {
  //               this.log('Error deleting temporary file [%s]: %o', zipFilePath, error);
  //               console.error(`Unable to remove temporary ZIP file ${zipFilePath}:`);
  //               console.error(error);
  //             }
  //             // But otherwise eat the error message
  //           });
  //           resolve();
  //         })
  //         .catch(reject);
  //     });
  //   });
  // }

  /**
   * Extracts clinical trials within a ZIP file.
   * @param zipPath the path to the ZIP file
   * @param opts the options
   */
  // private extractZip(zipPath: string): Promise<void> {
  //   this.log('Extracting [%s]...', zipPath);
  //   return new Promise<void>((resolve, reject) => {
  //     yauzl.open(zipPath, { }, (err, zipFile) => {
  //       if (err) {
  //         reject(err);
  //       } else if (zipFile) {
  //         const pendingPromises: Promise<void>[] = [];
  //         // Now that we have the file, it's time to add some events to it
  //         zipFile.once('error', (err) => {
  //           reject(err);
  //         });
  //         zipFile.on('entry', (entry: yauzl.Entry) => {
  //           // This is where the bulk of our processing happens - we simply want to turn this into a proper cache entry
  //           // Ensure the file name is what we expect it to be
  //           const extensionIdx = entry.fileName.lastIndexOf('.');
  //           if (extensionIdx > 0) {
  //             // A dot at index 0 is malformed anyway. Actually, anything less than 11 will be rejected, but details
  //             if (entry.fileName.substring(extensionIdx).toLowerCase() === '.xml') {
  //               const nctNumber = entry.fileName.substring(0, extensionIdx);
  //               if (isValidNCTNumber(nctNumber)) {
  //                 if (entry.uncompressedSize > this.maxAllowedEntrySize) {
  //                   this.log('Skipping entry %s: uncompressed size %d is larger than maximum allowed!', entry.fileName, entry.uncompressedSize);
  //                 } else {
  //                   // In this case, add it to the cache
  //                   pendingPromises.push(new Promise<void>((resolve) => {
  //                     zipFile.openReadStream(entry, (err, entryStream) => {
  //                       if (err) {
  //                         this.log('Error reading entry %s: skipping!', entry.fileName);
  //                       } else if (entryStream) {
  //                         // Resolve with the Promise that actually finishes the thing
  //                         resolve(this.addCacheEntry(nctNumber, entryStream));
  //                         return;
  //                       }
  //                       // If we're here, there was an error or somehow the entryStream wasn't given. In either case,
  //                       // just resolve the Promise anyway and let this entry be skipped.
  //                       resolve();
  //                     });
  //                   }));
  //                 }
  //               }
  //             }
  //           }
  //         });
  //         Promise.all(pendingPromises).then(() => {
  //           // Once all the pending promises from the entries (if any) are done, we can resolve
  //           resolve();
  //         });
  //       } else {
  //         reject(new Error('Invalid state: no error or zip file given.'));
  //       }
  //     });
  //   });
  // }

  // private addCacheEntry(nctNumber: NCTNumber, dataStream: stream.Readable): Promise<void> {
  //   // The cache entry should already exist
  //   const filename = path.join(this.cacheDataDir, nctNumber + '.xml');
  //   const promise = new Promise<void>((resolve, reject) => {
  //     // This indicates whether no error was raised - close can get called anyway, and it's slightly cleaner to just
  //     // mark that an error happened and ignore the close handler if it did.
  //     // (This also potentially allows us to do additional cleanup on close if an error happened.)
  //     let success = true;
  //     dataStream.pipe(fs.createWriteStream(filename)).on('error', (err) => {
  //       // If the cache entry exists in pending mode, delete it - we failed to create this entry
  //       // TODO: Does this failure destroy the existing cache entry?
  //       const entry = this.cache.get(nctNumber);
  //       if (entry && entry.pending) {
  //         this.cache.delete(nctNumber);
  //       }
  //       // TODO: Do we also need to delete the file? Or will the error prevent the file from existing?
  //       success = false;
  //       reject(err);
  //     }).on('close', () => {
  //       if (success) {
  //         // Once saved, resolve both the pending entry and this promise
  //         const entry = this.cache.get(nctNumber);
  //         if (entry && entry.pending) {
  //           entry.ready();
  //         }
  //         resolve();
  //       }
  //     });
  //   });
  //   return promise;
  // }

  /**
   * Loads a ClinicalStudy from an extracted dataset. This will never download a copy, this will only ever return from
   * within the cache.
   * @param nctNumber the NCT number
   * @returns a Promise that resolves to either the parsed ClinicalStudy or to null if the ClinicalStudy does not exist
   */
  getCachedClinicalStudy(nctNumber: NCTNumber): Promise<ClinicalStudy | null> {
    const entry = this.cache.get(nctNumber);
    if (entry) {
      return entry.load();
    } else {
      return Promise.resolve(null);
    }
  }

    /**
   * Loads a ClinicalStudy by downloading it from the s3 bucket.
   * @param nctNumber the NCT number
   * @returns a Promise that resolves to either the parsed ClinicalStudy or to null if the ClinicalStudy does not exist
   */
     async getCachedClinicalStudyFromS3Bucket(nctNumber: NCTNumber): Promise<ClinicalStudy | null> {

      const s3data = await s3.getObject(
        { Bucket: "cache-storage-ctm", Key: (nctNumber + ".xml") },
        function (error: any, data: any) {
          if (error != null) {
            console.log("Failed to retrieve an object: " + error);
          } else {
            console.log("Loaded " +  data + " with nct id " + nctNumber + " from s3.");
            return (data);
          }
        }
      ).promise();

      console.log("Raw s3 data loaded " + s3data + " from the s3 bucket with trial id " + nctNumber + ". Raw s3 data type: " + typeof s3data + ". Object protoype: " + Object.prototype.toString.call(s3data));

      if(s3data == null || s3data == undefined){
        console.log("NULL/UNDEFINED: Raw s3 data " + s3data + " from the s3 bucket with trial id " + nctNumber + " is null/undefined.");
      }

      console.log("Stringified Raw s3 data: " + JSON.stringify(s3data) + " from the s3 bucket with trial id " + nctNumber + ".");

      console.log("Raw s3 data .body " + s3data.body + "; Raw s3 data .Body " + s3data.Body + " from the s3 bucket with trial id " + nctNumber + ". Raw s3 data type: " + typeof s3data + ".");

      const dataBody = s3data.Body.toString('utf-8');

      console.log("toString()'ed Data Body loaded " + dataBody + " from the s3 bucket with trial id " + nctNumber + ". Databody type: " + typeof dataBody + ".");

      let entry = (parseClinicalTrialXML(dataBody, nctNumber));

      console.log("Parsed " + entry + " from the s3 bucket with trial id " + nctNumber + ".");

      return entry;
    }

  /**
   * The provides a stub that handles updating the research study with data from a clinical study downloaded from the
   * ClinicalTrials.gov website. This primarily exists as a stub to allow the exact process which updates a research
   * study to be overridden if necessary.
   *
   * @param researchStudy the research study to update
   * @param clinicalStudy the clinical study to update it with
   */
  updateResearchStudy(researchStudy: ResearchStudy, clinicalStudy: ClinicalStudy): void {
    updateResearchStudyWithClinicalStudy(researchStudy, clinicalStudy);
  }

  /**
   * Creates and initializes a new service for retrieving data from http://clinicaltrials.gov/. This will automatically
   * invoke the init method to create the directory if it doesn't exist and load any existing data if it does. Note that
   * the init method will not create missing parent directories - the path to the cache directory must already exist
   * minus the cache directory itself. If the cache directory cannot be created the Promise will be rejected with the
   * error preventing it from being created.
   *
   * @param dataDir the data directory
   * @param options additional options that can be set to further configure the trial service
   * @returns a Promise that resolves when the service is ready
   */
  static create(dataDir: string, options?: ClinicalTrialsGovServiceOptions): Promise<ClinicalTrialsGovService> {
    const result = new ClinicalTrialsGovService(dataDir, options);
    return result.init().then(() => result);
  }
}

/**
 * Creates and initializes a new service for retrieving data from http://clinicaltrials.gov/. This is the same as
 * ClinicalTrialsGovService.create, see that method for details.
 *
 * @param dataDir the data directory
 * @param options additional options that can be set to further configure the trial service
 * @returns a Promise that resolves when the service is ready
 */
export function createClinicalTrialsGovService(dataDir: string, options?: ClinicalTrialsGovServiceOptions): Promise<ClinicalTrialsGovService> {
  return ClinicalTrialsGovService.create(dataDir, options);
}

/**
 * Updates a research study with data from a clinical study off the ClinicalTrials.gov website. This will only update
 * fields that do not have data, it will not overwrite any existing data.
 *
 * @param result the research study to update
 * @param study the clinical study to use to update (this takes a partial as the ClinicalStudy type describes the XML
 * as the schema defines it, so this is designed to handle invalid XML that's missing information that should be
 * required)
 */
export function updateResearchStudyWithClinicalStudy(
  result: ResearchStudy,
  study: Partial<ClinicalStudy>
): ResearchStudy {
  if (!result.enrollment) {
    const eligibility = study.eligibility;
    if (eligibility) {
      const criteria = eligibility[0].criteria;
      if (criteria) {
        const group: Group = { resourceType: 'Group', id: 'group' + result.id, type: 'person', actual: false };
        const reference = addContainedResource(result, group);
        reference.display = criteria[0].textblock[0];
        result.enrollment = [reference];
      }
    }
  }
  if (!result.description) {
    const briefSummary = study.brief_summary;
    if (briefSummary) {
      result.description = briefSummary[0].textblock[0];
    }
  }
  if (!result.phase) {
    const phase = study.phase;
    if (phase) {
      result.phase = {
        coding: [
          {
            system: 'http://terminology.hl7.org/CodeSystem/research-study-phase',
            code: phase[0],
            display: phase[0]
          }
        ],
        text: phase[0]
      };
    }
  }
  if (!result.category) {
    const studyType = study.study_type;
    if (studyType) {
      result.category = [{ text: studyType[0] }];
    }
  }
  if (!result.status) {
    const overallStatus = study.overall_status;
    if (overallStatus) {
      const status = convertClincalStudyStatusToFHIRStatus(overallStatus[0]);
      if (typeof status !== 'undefined') result.status = status;
    }
  }

  if (!result.condition) {
    if (study.condition) {
      result.condition = convertArrayToCodeableConcept(study.condition);
    }
  }
  if (!result.site) {
    if (study.location) {
      let index = 0;
      for (const location of study.location) {
        const fhirLocation: Location = { resourceType: 'Location', id: 'location-' + index++ };
        if (location.facility) {
          if (location.facility[0].name)
            fhirLocation.name = location.facility[0].name[0];
          if (location.facility[0].address) {
            // Also add the address information
            const address = location.facility[0].address[0];
            fhirLocation.address = { use: 'work', city: address.city[0], country: address.country[0] };
            if (address.state) {
              fhirLocation.address.state = address.state[0];
            }
            if (address.zip) {
              fhirLocation.address.postalCode = address.zip[0];
            }
          }
        }
        if (location.contact) {
          const contact = location.contact[0];
          if (contact.email) {
            addToContainer<Location, ContactPoint, 'telecom'>(fhirLocation, 'telecom', {
              system: 'email',
              value: contact.email[0],
              use: 'work'
            });
          }
          if (contact.phone) {
            addToContainer<Location, ContactPoint, 'telecom'>(fhirLocation, 'telecom', {
              system: 'phone',
              value: contact.phone[0],
              use: 'work'
            });
          }
        }
        addToContainer<ResearchStudy, Reference, 'site'>(result, 'site', addContainedResource(result, fhirLocation));
      }
    }
  }
  return result;
}
